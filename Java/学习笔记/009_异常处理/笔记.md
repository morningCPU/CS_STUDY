# 009 异常处理
## 1. 异常概述
### 1.1 什么是异常
+ 异常 : 程序在执行过程中,出现的非正常情况
并不是指语法和逻辑错误
### 1.2 异常的抛出机制
+ java中异常通过类表示
1. 发生异常,创建该异常类型的对象,然后抛出(throw)
2. 程序员捕获异常(catch)
3. 如果没有捕获会导致程序的终止
### 1.3 异常的处理方法
1. 终止
2. 异常处理

***

## 2. java的异常体系
### 2.1 Throwable
`java.lang.Throwable` 类是异常事件类的根父类
+ 常用方法
**public void printStackTrace()** 打印异常信息
**public String getMessage** 获取发生异常的原因
### 2.2 Error 和 Exception
Throwable 的两个子类
+ **Error** JVM无法解决的严重错误,一般不写代码处理
+ **Exception** 一般性问题,需要针对性处理
编译时异常,运行时异常
### 2.3 常见运行时异常
+ ArrayIndexOutOfBoundsException
+ NullPointerException
+ ClassCastException
+ NumberFormatException
+ InputMismatchException
+ ArithmeticException
### 2.4 常见编译时异常
+ ClassNotFoundException
+ FileNotFoundException
+ IOException

***

## 3. 异常的处理
### 3.1 try-catch-finally
#### 3.1.1 格式
```java
try{
    // 可能出现问题的部分
}
catch(异常){

}
catch(异常){

}
finally{
    // 无论是否异常都执行
}
```
+ 具体实例
```java
try {
    int a = scan.nextInt();
    int b = scan.nextInt();
    System.out.println(a/b);
} catch (ArithmeticException e) {
    System.out.println("除零错误");
    System.out.println(e.getMessage());
} catch(InputMismatchException e){
    System.out.println("输入类型错误");
}
```
#### 3.1.2 开发体会
+ 对于运行时异常一般不进行显示处理
+ FileNotFoundException 是 IOException 的子类,可以只写 IOException
+ 编译时异常必须处理,不然编译无法通过

#### 3.1.3 finally的使用
+ catch里发生错误时会直接终止程序,不写在finally里中的内容就不会执行
finally里中的内容依旧会执行
+ 特殊情况
```java
public void test1(){
    int a = show();
    System.out.println(a);
}
public int show(){
    int n = 10;
    try{
        return n;
    }finally{
        ++n;
    }
}
```
结果为 10 (原来的10已经放到栈里了)
+ 注意有例外 finally 不会执行 : System.exit(0) 会强制停止JVM

#### 3.1.4 要放在finally中的代码
+ 输入输出流,数据库连接,Socket连接等资源需要显式关闭
+ **实例**
```java
public void test(){
FileInputStream fis = null;
    try {
        File file = new File("E:\\Code\\JAVA\\java_learning\\basic\\src\\test\\001.txt");
        fis = new FileInputStream(file);
        int data = fis.read();
        while(data!=-1){
            System.out.print((char)data);
            data = fis.read();
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally{
        try {
            if(fis != null)
                fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 3.2 throws
#### 3.2.1 格式
```java
public void test() throws IOException
```
#### 3.2.2 具体实例
```java
public void test2() throws IOException{
    File file = new File("E:\\Code\\JAVA\\java_learning\\basic\\src\\test\\001.txt");
    FileInputStream fis = new FileInputStream(file);
    int data = fis.read();
    while (data != -1) {
        System.out.print((char) data);
        data = fis.read();
    }
    fis.close();
}
void test3(){
    try {
        test2();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
+ throws 只是抛出异常,并未对异常进行处理
### 3.3.4 重写的要求
子类的 throws 不能大于父类

## 3.4 两种方式的选择
+ 资源一定要被执行 try-catch-finally
+ 重写 try-catch-finally
+ 调用递进方法 throws

***

## 4. 手动抛出异常对象
### 4.1 目的
出现不满足具体场景的代码问题,需要手动抛出一个指定类型的异常对象

### 4.2 具体实例
+ 使用 `throw` (注意没有 `s`)
```java
public void regist(int id){
    if(id > 0){
        this.id = id;
    }else{
        throw new RuntimeException("输入的id非法");
    }
}
```

## 5. 自定义异常对象

### 5.1 定义
继承原本的异常类
```java
public class BelowZeroException extends Exception{
    @java.io.Serial
    static final long serialVersionUID = -70348766939L;

    public BelowZeroException(){
        
    }

    public BelowZeroException(String name){
        super(name);
    }

    public BelowZeroException(String message,Throwable cause){
        super(message,cause);
    }
}
```

### 5.2 为什么需要自定义异常类
为了见名知意 
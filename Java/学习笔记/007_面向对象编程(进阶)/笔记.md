# 007_面向对象编程（进阶）

## 1. this 关键字
### 1.1 this的使用情况
#### 1.1.1 实例方法或构造器中使用当前对象的成员
```java
public class Student{
    String name;
    public void setName(String name){
        this.name = name; // 注意不是指针,java也没有指针
    }
}
```
+ 使用 `this` 访问属性和方法时,如果在本类中未找到,会在父类中找

#### 1.1.2 同一个类中构造器相互调用
+ `this()` 调用本类的无参构造器
+ `this(实参列表)` 调用本类的有参构造器

```java
public class Num{
    private String a;
    private int b;
    public Num(){
        this("a",2);
    }
    public Num(int b){
        this();
        this.b = b;
    }
    public Num(String a,int b){
        this(b);
        this.a = a;
    }
}
```
+ 不能出现递归调用
+ this()和this(参数列表)只能声明在构造器的首行,所以最多只能有一个this()/this(参数列表)

***

## 2. 继承
使用 `extends`
### 2.1 java中的继承
#### 2.1.1 自上而下
```java
class Person{
    public String name;
    public int age;
    public Date birthDate;
}
class Student extends Person{
    public String school;
}
```
+ Student类继承了父类Person的所有属性和方法，并增加了一个属性school。Person中的属性和方法，Student都可以使用。

### 2.2 继承的语法
#### 2.2.1 格式
```java
class Person{}
class Student extends Person{}
```

#### 2.2.2 基本概念
+ 子类 SubClass
+ 父类 SuperClass

#### 2.2.3 相关说明
+ 子类会继承父类所有的实例变量和实例方法
+ 子类不能直接访问父类的私有成员变量和方法
+ java支持多级继承,顶层父类是Object类
+ 一个父类可以同时拥有过个子类
+ 只支持单继承,一个子类只有一个直接父类

***

## 3. 方法的重写
`override` 和 `overwrite`

### 3.1 方法重写示例
```java
class Person{
    public int getId(){}
}
class Student{
    @Override // 注意O要大写
    public int getId(){}
}
```
+ @Override 写在重写的方法上面，不写也没事，但写了方便编译器检查

### 3.2 方法重写的要求
+ 子类重写的方法的返回值不能大于父类被重写的方法的返回值类型(比如Student < Person)
但是如果是基本数据类型和void则必须要一样
+ 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
(public > protected > 缺省 > private)
+ 父类私有方法不能重写
跨包的父类缺省的方法也不能重写
+ 子类方法抛出的异常不能大于父类被重写方法的异常

***

## 4. 访问权限
+ 外部类要跨包使用必须是 public , 否则仅限本包使用

***

## 5. super 关键字
super 用于调用父类中的指定操作
+ 在构造器的首行 `this(形参列表)` 和 `super(形参列表)` 只能有其中的一个
+ 如果子类默认调用父类的无参构造

***

## 6. 多态性
### 6.1 格式
父类类型 变量名 = 子类对象
```java
Person p = new Student();
```
+ 子类扩展不可用

### 6.2 虚方法调用
父类中被子类重写的方法叫做虚方法

### 6.3 向上转型和向下转型
一个对象在 new 的时候是什么类型的,那它从头到尾就不会变,即运行时类型不会变
但是编译时类型可以变
+ 向上转型只能使用子类重写的方法
+ 向下转型才能调用子类独有的方法
```java
void work(Animal a) {
    if (a instanceof Dog) {
        ((Dog) a).wagTail();   // Dog 才有摇尾巴
    }
}
```
+ 向上转型自动完成
+ 向下转型 (子类类型)父类变量

### 6.4 instanceof
```java
//检验对象a是否是数据类型A的对象,返回值为boolean型
a instanceof A
```
+ 要求对象a所属的类与类A必须是子类和父类的关系

***

## 7. Object 类的使用
类 `java.lang.Object` 是类层次结构的根,是所有其他类的父类

### 7.1 Object类的方法
#### 7.1.1 equals()
+ 只能比较引用数据类型
+ 格式 `obj1.equals(obj2)`
+ `equals()` 如果没有被重写那也是 `==` 的功能
+ 对于 `String` 中比较值的错觉是因为在他们中 `equals()` 已经被重写了

#### 7.1.2 toString()
+ 默认情况下`toString()`返回的是`对象的运行是类型@对象的hashCode值的十六进制形式`

#### 7.1.3 clone()
复制
```java
Animal a = new Animal("1");
Animal b = (Animal)a.clone();
```
+ 注意要转换为原来的数据类型,不然编译器会警告

#### 7.1.4 finalize()
自动调用回收

#### 7.1.5 getClass()
获取对象的运行时类型


#### 7.1.6 hashCode()
返回每个对象的hash值
































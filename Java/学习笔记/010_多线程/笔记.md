# 010 多线程
## 1. 相关概念
### 1.1 程序、进程、线程
+ 程序: 一组指令的集合,是静态的
+ 进程: 程序的一次执行过程
+ 线程: 程序内部的一条执行路径
### 1.2 线程调度
+ 分时调度,轮流使用
+ 抢占式调度,优先级,java使用
### 1.3 多线程优点
+ 提高应用程序的响应
+ 提高计算机系统的CPU利用率
+ 改善程序结构

***

## 2. 创建和启动线程
### 2.1 概述
+ 使用 `java.lang.Thread` 类表示线程
### 2.2 方法一: 继承 Thread 类
1. 创建一个继承于 Thread 类的子类
2. 重写 Thread 类的 run() 方法
run() 方法就是这个线程要进行的操作
3. 创建对象
4. 通过对象调用 start() 方法(Thread的方法)
start(): 启动线程,调用当前线程的run()方法
不能 start() 多次
+ **具体实例**
```java
public class EvenNumberTest {
    public static void main(String[] args) {
        PrintNumber1 printNumber1 = new PrintNumber1();
        PrintNumber2 printNumber2 = new PrintNumber2();
        printNumber1.start();
        printNumber2.start();
    }
}

class PrintNumber2 extends Thread {
    @Override
    public void run() {
        for (int i = 2; i <= 100; i += 2) {
            System.out.println(PrintNumber2.currentThread().getName() + ":" + i);
        }
    }
}

class PrintNumber1 extends Thread{
    @Override
    public void run() {
        for(int i =1 ;i<=100;i+=2){
            System.out.println(PrintNumber1.currentThread().getName() + ":" + i);
        }
    }
}
```
### 2.2 方法二: 实现 Runnable 接口
1. 创建一个实现Runnable接口的类
2. 实现接口中的run()方法
3. 创建当前实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中,创建Thread类的实例
5. 通过 Thread 类的实例调用 start() 方法
+ **具体实现**
```java
public class EvenNumberTest {
    public static void main(String[] args) {
        EvenNumberPrint1 evenNumberPrint1 = new EvenNumberPrint1();
        EvenNumberPrint2 evenNumberPrint2 = new EvenNumberPrint2();
        Thread t1 = new Thread(evenNumberPrint1);
        Thread t2 = new Thread(evenNumberPrint2);
        t1.start();
        t2.start();
    }
}

class EvenNumberPrint2 implements Runnable{
    @Override
    public void run() {
        for(int i = 2;i<=100;i+=2){
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}class EvenNumberPrint1 implements Runnable{
    @Override
    public void run() {
        for(int i = 1;i<=100;i+=2){
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
```
### 2.3 方式三 匿名函数
```java
Thread t3 = new Thread(new Runnable(){
    @Override
    public void run() {
        for(int i = 1;i<=100;i+=2){
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
});
t3.start();
```

### 2.4 两种方式的对比
+ 共同点 创建的对象都是Thread类或其子类的对象

### 2.5 用 Runnable 实现的优点
+ 让继承可用
+ 便于资源共享
+ 数据和代码分离

***

## 3. 线程的常用结构
### 3.1 线程中的构造器
+ public Thread() 分配一个新的线程对象
+ public Thread(String name) 分配一个指定名字的新的线程对象
+ public Thread(Runnable target) 指定创建线程的目标对象,他实现Runnable接口中的run方法
+ public Thread(Runnable target,String name) 分配一个带有指定目标新的线程对象并指定名字

### 3.2 线程中的常用方法
+ start()
+ run()
+ currentThread()
+ getName()
+ setName()
+ sleep(long millis) : Thread.sleep() 延时多少毫秒
会抛出 InterruptedException 异常,需要手动处理
+ yield() : Thread.yield() 释放CPU的使用
+ join() : 非静态,在线程a中通过线程b调用join(),意味着线程a进入阻塞状态,直到线程b执行结束,线程a才恢复
+ isAlive()

### 3.3 线程的优先级
+ getPriority() 获取优先级
+ setPriority() 设置优先级
+ 范围 1-10
+ 优先级高并不代表一定就会先执行,只是概率更大
+ Thread类内部声明的三个常量
MAX_PRIORITY    (10)  最高优先级
MIN_RTIORITY    (1)   最低优先级
NORM_PRIORITY   (5)   普通优先级

***

## 4. 同步机制
### 4.1 同步代码块
使用 `synchronized`
+ **使用格式**
```java
synchronized(同步监视器){
    //需要同步的代码
}
```
+ 需要同步的代码,多个线程都需要进行操作的代码片段
+ 同步监视器,锁
可以使用任何一个类的对象充当,多个线程必须共用同一个监视器,监视器必须唯一
+ **具体实例**
```java
rivate final Object obj = new Object();
@Override
public void run() {
    while (true) {
        synchronized (ojb) { // 也可以为 (this),注意要唯一,实现方法可以,继承方法不可以,继承可以用 类.class
            if (tickets > 0) {
                System.out.println(Thread.currentThread().getName() + "售票 " + tickets);
                tickets--;
                count++;
            } else {
                break;
            }
        }
    }
}
```
+ 在实现中同步监视器使用 this,在继承中同步监视器使用 类.class (同步也可以用)

### 4.2 同步方法
当操作共享数据的代码完整地声明在一个方法中,那么可以将此方法声明为一个同步方法
方法加上 synchronized
`public synchronized void show(){}`
+ 默认同步监视器是 `this` (非静态方法),`类.class`(静态方法),不可自行改动

### 4.3 synchronized 的优劣
+ 优点 : 解决了线程的安全问题
+ 弊端 : 在操作共享数据时,多线程其实是串行执行的,意味着性能低

## 5. 线程安全的懒汉式
+ **示例代码**
```java
calss Bank{
    private Bank(){}
    private static volatile Bank bank = null; // 加上volatile避免指令重排问题
    public static getInstance(){
        if(bank == null){
            synchronized(Bank.class){
                if(bank == null){
                    bank = new Bank();
                }
            }
        }
        return bank;
    }
}
```

***

## 6. Lock的使用
+ 使用 `ReentrantLock` 类
要保证对象唯一
`private static final ReentrantLock lock = new ReentrantLock();`
+ `lock()` 加锁
+ `unlock()` 解锁
unlock()要保证一定会执行
```java
try{
    lock.lock();

}finally{
    lock.unlock();
}
```
***

## 7. 线程之间的通讯
使用 `wait` , `notify` , `notifyAll`
+ wait 会释放监视器
+ 只能使用在同步代码块或同步方法中,方法的调用者必须是同步监视器  

***

## 8. Callable 接口

## 9. 线程池

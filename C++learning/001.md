# 对象
对象 = 属性 + 服务
主要就是有了类(class)的概念
示例：
```
class A{
    public :
        A(int x,int y);
        void print();
    private :
        int x;
        int y;
};//记得要有分号
```
特性：封装，继承，多态

用 extern 可以进行声明

头文件格式
```
#ifndef A
#define A

...

#endif
```

一个头文件里放一个类的声明

# 成员变量
类不是实体，对象才有实体
变量属于对象，函数属于类

# 构造与析构
+ 构造函数
函数名与类名相同
+ 默认构造函数
没有参数的构造函数
+ 析构函数
类名前加一个 `~`
+ 初始化列表
示例：
```
class Point{
    public:
        Point(int x,int y):x(x),y(y);
        void print() const;
    private:
        int x;
        int y;
};
```

要注意区分声明和定义

# 动态内存分配

先分配空间再调用构造函数
+ *a = new int;
+ *b = new int[10];
先调用析构函数在去除分配的空间
+ delete a;
+ delete[] b;

# 访问限制
+ public : 公共的
+ private : 私有的,只有自己可以访问
+ protected : 受保护的,只有自己和自己的子孙可以访问
class 和 struct 类似，
不同之处在于 class默认访问权限为private,struct默认访问权限为public
+ friend : 友元
示例:friend class A;

# 初始化列表
 示例:
 ```
class Point{
    private:
        const float x,y;
        Point(float xa,float ya):x(xa),y(ya){}
};
 ```
 初始化列表执行在构造函数之前

# 对象组合
 
# 继承
子类不能直接使用父类的private

# 内联函数
inline
body放在头文件中
# 默认参数
要写在函数原型中
# const
+ char * const q = "abc"
q 是 const
+ const char * q = "abc" / char const *q = "abc"
*q 是 const
+ const char * const q = "abc"
q 和 *q 是 const

# 不可修改的对象
在函数后面加上 const 表示这个函数不发生内容的修改
```
class A{
    public : 
        void f(){}
        void f() const{}
};
```
其中 void f(){} 其实是 void f(A * this){}
void f() const() 其实是 void f(const A * this){}

# 引用
int x;
int &y = x;
此时x,y相当于是一样的，改变x就会改变y,改变y就会改变x

int x;
const int &y = x;
此时不能改变 y 的值,但是可以改变 x 的值

# 向上造型
基类的指针可以指向子类的地址

# 多态性
+ virtual : 让子类和父类有联系
+ 动态联编，静态联编

# 虚析构
+ 多态状态下构造函数的调用顺序：
先基类后派生类
+ 多态状态下析构函数的调用顺序：
只调用基类，可以用virtual解决这个问题
先派生类后基类
注意：构造函数不能是虚函数
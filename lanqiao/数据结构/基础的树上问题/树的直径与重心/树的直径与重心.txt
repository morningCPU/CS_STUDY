树的直径
+   树上最长的一条链，可能不唯一
+   求树的直径的两种方法：
    1.跑两遍dfs
    2.树形dp
+   跑两遍dfs

树的重心
+   将某一个点删除后可以使得剩余连通块的大小的最大值最小的点
+   用mss[x]表示x点的所有子树大小的最大值
+   树的重心的性质
    1.重心的若干棵子树的大小一定小于n/2
      除了重心以外的所有其他点，都必然存在一棵结点个数大于n/2的子树
    2.一棵树至多有两个重心，如果有两个重心，则必然相邻
      将连接两个重心的边删除后，一定划分为两棵大小相等的树
    3.树中所有点到某个点的距离和中，到重心的距离和是最小的
+   求树的重心
    void dfs(int x,int fa)
    {
        sz[x] = 1,mss[x] = 0;
        for(const auto &y:g[x])
        {
            if(y == fa)continue;
            dfs(y,x);
            sz[x] += sz[y];
            mss[x] = max(mss[x],sz[y]);
        }
        mss[x] = max(mss[x],n - sz[x]);
        if(mss[x] <= n/2)v.push_back(x);
    }
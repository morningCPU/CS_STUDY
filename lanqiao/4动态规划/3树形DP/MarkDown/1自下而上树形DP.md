# 自下而上树形DP

## 1.解决方法
通常通过 `dfs` 的方式遍历树，并使用一个数组或哈希表来存储子问题的解

***

## 2.基本概念
+ 状态定义 `dp[u]` 表示以 `u` 为根的子树中满足条件的解

***

## 3.自下而上树形DP
```
void dfs(int x,int fa)
{
    for(const auto &y:g[x])
    {
        if(y == fa)continue;
        dfs(y,x);
    }
}
```

***

## 4.第一类转移
完全通过子节点来更新父节点，子树之间没有关联

***

## 5.第二类转移
子树之间相互有关联